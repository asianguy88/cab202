   1               		.file	"blockhead.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	__addsf3
  11               	.global	__gesf2
  12               	.global	__floatsisf
  13               		.section	.text.update_blockhead,"ax",@progbits
  14               	.global	update_blockhead
  16               	update_blockhead:
  17               	.LFB9:
  18               		.file 1 "blockhead.c"
   1:blockhead.c   **** /*
   2:blockhead.c   **** *	File:	blockhead.c
   3:blockhead.c   **** *	Author: Lawrence Buckingham, Queensland University of Technology.
   4:blockhead.c   **** *	Date:	27 April 2015.
   5:blockhead.c   **** *
   6:blockhead.c   **** *	Implementation of the blockhead walking sequence.
   7:blockhead.c   **** */
   8:blockhead.c   **** 
   9:blockhead.c   **** #include "friendly_ports.h" 
  10:blockhead.c   **** #include "graphics.h"
  11:blockhead.c   **** #include "byte.h"
  12:blockhead.c   **** #include "sprite.h"
  13:blockhead.c   **** #include <util/delay.h>
  14:blockhead.c   **** 
  15:blockhead.c   **** void do_the_walk( void );
  16:blockhead.c   **** void update_blockhead( Sprite *the_block );
  17:blockhead.c   **** 
  18:blockhead.c   **** void walk_the_walk( void ) {
  19:blockhead.c   **** 	clear_screen();
  20:blockhead.c   **** 	turn_on( LED1 );
  21:blockhead.c   **** 	draw_string( 0, 0, "Click to walk..." );
  22:blockhead.c   **** 	show_screen();
  23:blockhead.c   **** 	wait_until( pressed( SW2 ) );
  24:blockhead.c   **** 	_delay_ms(100);
  25:blockhead.c   **** 	wait_until( !pressed( SW2 ) );
  26:blockhead.c   **** 	turn_off( LED1 );
  27:blockhead.c   **** 
  28:blockhead.c   **** 	do_the_walk();
  29:blockhead.c   **** 
  30:blockhead.c   **** 	clear_screen();
  31:blockhead.c   **** 	turn_on( LED1 );
  32:blockhead.c   **** 	draw_string( 0, 0, "Walk over." );
  33:blockhead.c   **** 	draw_string( 0, 8, "Click to exit..." );
  34:blockhead.c   **** 	show_screen();
  35:blockhead.c   **** 	wait_until( pressed( SW2 ) );
  36:blockhead.c   **** 	_delay_ms(100);
  37:blockhead.c   **** 	wait_until( !pressed( SW2 ) );
  38:blockhead.c   **** 	turn_off( LED1 );
  39:blockhead.c   **** }
  40:blockhead.c   **** 
  41:blockhead.c   **** void do_the_walk() {
  42:blockhead.c   **** 	// Notes: 
  43:blockhead.c   **** 	//	byte is typedef name for unsigned char, defined in byte.h
  44:blockhead.c   **** 	//	UINT and BYTE macros provide a standards-compliant way to express
  45:blockhead.c   **** 	//	a binary literal ... the 0b00000000 notation supported by gcc is
  46:blockhead.c   **** 	//	not defined in the Standard C language.
  47:blockhead.c   **** 	static unsigned char bitmap0[] = {
  48:blockhead.c   **** 		UINT( 00001111, 10000000 ),
  49:blockhead.c   **** 		UINT( 00001000, 10000000 ),
  50:blockhead.c   **** 		UINT( 00001000, 10000000 ),
  51:blockhead.c   **** 		UINT( 00001111, 10000000 ),
  52:blockhead.c   **** 		UINT( 00000010, 00000000 ),
  53:blockhead.c   **** 		UINT( 00001111, 10000000 ),
  54:blockhead.c   **** 		UINT( 00010010, 01000000 ),
  55:blockhead.c   **** 		UINT( 00100010, 00100000 ),
  56:blockhead.c   **** 		UINT( 01000010, 00010000 ),
  57:blockhead.c   **** 		UINT( 10000010, 00001000 ),
  58:blockhead.c   **** 		UINT( 00000010, 00000000 ),
  59:blockhead.c   **** 		UINT( 00000101, 00000000 ),
  60:blockhead.c   **** 		UINT( 00001000, 10000000 ),
  61:blockhead.c   **** 		UINT( 00001000, 10000000 ),
  62:blockhead.c   **** 		UINT( 00001000, 10000000 ),
  63:blockhead.c   **** 		UINT( 00010000, 01000000 ),
  64:blockhead.c   **** 		UINT( 00010000, 01000000 ),
  65:blockhead.c   **** 		UINT( 00100000, 00100000 ),
  66:blockhead.c   **** 		UINT( 00100000, 00100000 ),
  67:blockhead.c   **** 		UINT( 11100000, 00111000 ),
  68:blockhead.c   **** 	};
  69:blockhead.c   **** 	static byte bitmap3[] = {
  70:blockhead.c   **** 		UINT( 00001111, 10000000 ),
  71:blockhead.c   **** 		UINT( 00001000, 10000000 ),
  72:blockhead.c   **** 		UINT( 00001000, 10000000 ),
  73:blockhead.c   **** 		UINT( 00001111, 10000000 ),
  74:blockhead.c   **** 		UINT( 00000010, 00000000 ),
  75:blockhead.c   **** 		UINT( 00000111, 00000000 ),
  76:blockhead.c   **** 		UINT( 00001010, 10000000 ),
  77:blockhead.c   **** 		UINT( 00010010, 10000000 ),
  78:blockhead.c   **** 		UINT( 00010010, 01000000 ),
  79:blockhead.c   **** 		UINT( 00010010, 00100000 ),
  80:blockhead.c   **** 		UINT( 00000010, 00000000 ),
  81:blockhead.c   **** 		UINT( 00000011, 00000000 ),
  82:blockhead.c   **** 		UINT( 00000010, 11000000 ),
  83:blockhead.c   **** 		UINT( 00000010, 00100000 ),
  84:blockhead.c   **** 		UINT( 00000010, 11000000 ),
  85:blockhead.c   **** 		UINT( 00000011, 00000000 ),
  86:blockhead.c   **** 		UINT( 00001110, 00000000 ),
  87:blockhead.c   **** 		UINT( 00010010, 00000000 ),
  88:blockhead.c   **** 		UINT( 00010010, 00000000 ),
  89:blockhead.c   **** 		UINT( 00000011, 10000000 ),
  90:blockhead.c   **** 	};
  91:blockhead.c   **** 	static byte bitmap4[] = {
  92:blockhead.c   **** 		UINT( 00000111, 11000000 ),
  93:blockhead.c   **** 		UINT( 00000100, 01000000 ),
  94:blockhead.c   **** 		UINT( 00000100, 01000000 ),
  95:blockhead.c   **** 		UINT( 00000111, 11000000 ),
  96:blockhead.c   **** 		UINT( 00000001, 00000000 ),
  97:blockhead.c   **** 		UINT( 00000011, 10000000 ),
  98:blockhead.c   **** 		UINT( 00001101, 01000000 ),
  99:blockhead.c   **** 		UINT( 00110001, 00100000 ),
 100:blockhead.c   **** 		UINT( 00010010, 00011000 ),
 101:blockhead.c   **** 		UINT( 00000100, 00000000 ),
 102:blockhead.c   **** 		UINT( 00000100, 00000000 ),
 103:blockhead.c   **** 		UINT( 00000111, 00000000 ),
 104:blockhead.c   **** 		UINT( 00000100, 11000000 ),
 105:blockhead.c   **** 		UINT( 00000010, 00110000 ),
 106:blockhead.c   **** 		UINT( 00000001, 00001000 ),
 107:blockhead.c   **** 		UINT( 00000001, 00010000 ),
 108:blockhead.c   **** 		UINT( 00000001, 00100000 ),
 109:blockhead.c   **** 		UINT( 00000010, 00111000 ),
 110:blockhead.c   **** 		UINT( 00000100, 00000000 ),
 111:blockhead.c   **** 		UINT( 00001110, 00000000 ),
 112:blockhead.c   **** 	};
 113:blockhead.c   **** 	static byte bitmap1[] = {
 114:blockhead.c   **** 		UINT( 00001111, 10000000 ),
 115:blockhead.c   **** 		UINT( 00001000, 10000000 ),
 116:blockhead.c   **** 		UINT( 00001000, 10000000 ),
 117:blockhead.c   **** 		UINT( 00001111, 10000000 ),
 118:blockhead.c   **** 		UINT( 00000010, 00000000 ),
 119:blockhead.c   **** 		UINT( 00000111, 00000000 ),
 120:blockhead.c   **** 		UINT( 00001010, 10000000 ),
 121:blockhead.c   **** 		UINT( 00010010, 10000000 ),
 122:blockhead.c   **** 		UINT( 00010010, 01000000 ),
 123:blockhead.c   **** 		UINT( 00010010, 00100000 ),
 124:blockhead.c   **** 		UINT( 00000010, 00000000 ),
 125:blockhead.c   **** 		UINT( 00000111, 00000000 ),
 126:blockhead.c   **** 		UINT( 00000101, 00000000 ),
 127:blockhead.c   **** 		UINT( 00000100, 10000000 ),
 128:blockhead.c   **** 		UINT( 00001000, 01000000 ),
 129:blockhead.c   **** 		UINT( 00001000, 00100000 ),
 130:blockhead.c   **** 		UINT( 00010000, 00100000 ),
 131:blockhead.c   **** 		UINT( 00010000, 00100000 ),
 132:blockhead.c   **** 		UINT( 00100000, 00100000 ),
 133:blockhead.c   **** 		UINT( 00111000, 00111000 ),
 134:blockhead.c   **** 	};
 135:blockhead.c   **** 	static byte bitmap2[] = {
 136:blockhead.c   **** 		UINT( 00000011, 11100000 ),
 137:blockhead.c   **** 		UINT( 00000010, 00100000 ),
 138:blockhead.c   **** 		UINT( 00000010, 00100000 ),
 139:blockhead.c   **** 		UINT( 00000011, 11100000 ),
 140:blockhead.c   **** 		UINT( 00000000, 10000000 ),
 141:blockhead.c   **** 		UINT( 00000001, 11000000 ),
 142:blockhead.c   **** 		UINT( 00000110, 10100000 ),
 143:blockhead.c   **** 		UINT( 00011000, 10010000 ),
 144:blockhead.c   **** 		UINT( 00001000, 10011000 ),
 145:blockhead.c   **** 		UINT( 00000001, 00000000 ),
 146:blockhead.c   **** 		UINT( 00000001, 00000000 ),
 147:blockhead.c   **** 		UINT( 00000011, 10000000 ),
 148:blockhead.c   **** 		UINT( 00000010, 01000000 ),
 149:blockhead.c   **** 		UINT( 00000010, 00100000 ),
 150:blockhead.c   **** 		UINT( 00000010, 00010000 ),
 151:blockhead.c   **** 		UINT( 00000010, 00001000 ),
 152:blockhead.c   **** 		UINT( 00001100, 00010000 ),
 153:blockhead.c   **** 		UINT( 00110000, 00010000 ),
 154:blockhead.c   **** 		UINT( 00100000, 00100000 ),
 155:blockhead.c   **** 		UINT( 00000000, 00111000 ),
 156:blockhead.c   **** 	};
 157:blockhead.c   **** 
 158:blockhead.c   **** #define BITMAP_COUNT 4
 159:blockhead.c   **** 
 160:blockhead.c   **** 	static byte *bitmaps[BITMAP_COUNT] = {bitmap1, bitmap2, bitmap3, bitmap4};
 161:blockhead.c   **** 
 162:blockhead.c   **** 	const int width = 13;
 163:blockhead.c   **** 	const int height = sizeof( bitmap0 ) / 2;
 164:blockhead.c   **** 
 165:blockhead.c   **** 	Sprite blockhead;
 166:blockhead.c   **** 	init_sprite( &blockhead, (LCD_X - width) / 2, (LCD_Y - height) / 2, width, height, bitmap0 );
 167:blockhead.c   **** 	blockhead.dx = 1;
 168:blockhead.c   **** 	blockhead.dy = 0;
 169:blockhead.c   **** 
 170:blockhead.c   **** 	clear_screen();
 171:blockhead.c   **** 	draw_sprite( &blockhead );
 172:blockhead.c   **** 	show_screen();
 173:blockhead.c   **** 
 174:blockhead.c   **** 	db_wait();
 175:blockhead.c   **** 
 176:blockhead.c   **** 	int current_image = 0;
 177:blockhead.c   **** 	int walk_counter = 0;
 178:blockhead.c   **** 
 179:blockhead.c   **** 	turn_on( LED0 );
 180:blockhead.c   **** 	while ( !pressed( SW2 ) ) {
 181:blockhead.c   **** 		clear_screen();
 182:blockhead.c   **** 		walk_counter++;
 183:blockhead.c   **** 
 184:blockhead.c   **** 		if ( walk_counter % 10 == 0 ) {
 185:blockhead.c   **** 			current_image++;
 186:blockhead.c   **** 			current_image %= BITMAP_COUNT;
 187:blockhead.c   **** 			blockhead.bitmap = bitmaps[current_image];
 188:blockhead.c   **** 		}
 189:blockhead.c   **** 
 190:blockhead.c   **** 		update_blockhead( &blockhead );
 191:blockhead.c   **** 		
 192:blockhead.c   **** 		draw_sprite( &blockhead );
 193:blockhead.c   **** 		show_screen();
 194:blockhead.c   **** 		_delay_ms( 20 );
 195:blockhead.c   **** 	}
 196:blockhead.c   **** }
 197:blockhead.c   **** 
 198:blockhead.c   **** void update_blockhead( Sprite *the_block ) {
  19               		.loc 1 198 0
  20               		.cfi_startproc
  21               	.LVL0:
  22 0000 8F92      		push r8
  23               	.LCFI0:
  24               		.cfi_def_cfa_offset 3
  25               		.cfi_offset 8, -2
  26 0002 9F92      		push r9
  27               	.LCFI1:
  28               		.cfi_def_cfa_offset 4
  29               		.cfi_offset 9, -3
  30 0004 AF92      		push r10
  31               	.LCFI2:
  32               		.cfi_def_cfa_offset 5
  33               		.cfi_offset 10, -4
  34 0006 BF92      		push r11
  35               	.LCFI3:
  36               		.cfi_def_cfa_offset 6
  37               		.cfi_offset 11, -5
  38 0008 CF92      		push r12
  39               	.LCFI4:
  40               		.cfi_def_cfa_offset 7
  41               		.cfi_offset 12, -6
  42 000a DF92      		push r13
  43               	.LCFI5:
  44               		.cfi_def_cfa_offset 8
  45               		.cfi_offset 13, -7
  46 000c EF92      		push r14
  47               	.LCFI6:
  48               		.cfi_def_cfa_offset 9
  49               		.cfi_offset 14, -8
  50 000e FF92      		push r15
  51               	.LCFI7:
  52               		.cfi_def_cfa_offset 10
  53               		.cfi_offset 15, -9
  54 0010 CF93      		push r28
  55               	.LCFI8:
  56               		.cfi_def_cfa_offset 11
  57               		.cfi_offset 28, -10
  58 0012 DF93      		push r29
  59               	.LCFI9:
  60               		.cfi_def_cfa_offset 12
  61               		.cfi_offset 29, -11
  62               	/* prologue: function */
  63               	/* frame size = 0 */
  64               	/* stack size = 10 */
  65               	.L__stack_usage = 10
  66 0014 EC01      		movw r28,r24
 199:blockhead.c   **** 	the_block->x += the_block->dx;
  67               		.loc 1 199 0
  68 0016 2885      		ldd r18,Y+8
  69 0018 3985      		ldd r19,Y+9
  70 001a 4A85      		ldd r20,Y+10
  71 001c 5B85      		ldd r21,Y+11
  72 001e 6881      		ld r22,Y
  73 0020 7981      		ldd r23,Y+1
  74 0022 8A81      		ldd r24,Y+2
  75 0024 9B81      		ldd r25,Y+3
  76 0026 0E94 0000 		call __addsf3
  77               	.LVL1:
  78 002a 4B01      		movw r8,r22
  79 002c 5C01      		movw r10,r24
  80 002e 6883      		st Y,r22
  81 0030 7983      		std Y+1,r23
  82 0032 8A83      		std Y+2,r24
  83 0034 9B83      		std Y+3,r25
 200:blockhead.c   **** 	the_block->y += the_block->dy;
  84               		.loc 1 200 0
  85 0036 2C85      		ldd r18,Y+12
  86 0038 3D85      		ldd r19,Y+13
  87 003a 4E85      		ldd r20,Y+14
  88 003c 5F85      		ldd r21,Y+15
  89 003e 6C81      		ldd r22,Y+4
  90 0040 7D81      		ldd r23,Y+5
  91 0042 8E81      		ldd r24,Y+6
  92 0044 9F81      		ldd r25,Y+7
  93 0046 0E94 0000 		call __addsf3
  94               	.LVL2:
  95 004a 6B01      		movw r12,r22
  96 004c 7C01      		movw r14,r24
  97 004e 6C83      		std Y+4,r22
  98 0050 7D83      		std Y+5,r23
  99 0052 8E83      		std Y+6,r24
 100 0054 9F83      		std Y+7,r25
 201:blockhead.c   **** 
 202:blockhead.c   **** 	if ( the_block->x >= LCD_X ) {
 101               		.loc 1 202 0
 102 0056 20E0      		ldi r18,0
 103 0058 30E0      		ldi r19,0
 104 005a 48EA      		ldi r20,lo8(-88)
 105 005c 52E4      		ldi r21,lo8(66)
 106 005e C501      		movw r24,r10
 107 0060 B401      		movw r22,r8
 108 0062 0E94 0000 		call __gesf2
 109               	.LVL3:
 110 0066 87FD      		sbrc r24,7
 111 0068 00C0      		rjmp .L2
 203:blockhead.c   **** 		the_block->x = -the_block->width;
 112               		.loc 1 203 0
 113 006a 6889      		ldd r22,Y+16
 114 006c 70E0      		ldi r23,0
 115 006e 7195      		neg r23
 116 0070 6195      		neg r22
 117 0072 7109      		sbc r23,__zero_reg__
 118 0074 072E      		mov __tmp_reg__,r23
 119 0076 000C      		lsl r0
 120 0078 880B      		sbc r24,r24
 121 007a 990B      		sbc r25,r25
 122 007c 0E94 0000 		call __floatsisf
 123               	.LVL4:
 124 0080 6883      		st Y,r22
 125 0082 7983      		std Y+1,r23
 126 0084 8A83      		std Y+2,r24
 127 0086 9B83      		std Y+3,r25
 128               	.L2:
 204:blockhead.c   **** 	}
 205:blockhead.c   **** 
 206:blockhead.c   **** 	if ( the_block->y >= LCD_Y ) {
 129               		.loc 1 206 0
 130 0088 20E0      		ldi r18,0
 131 008a 30E0      		ldi r19,0
 132 008c 40E4      		ldi r20,lo8(64)
 133 008e 52E4      		ldi r21,lo8(66)
 134 0090 C701      		movw r24,r14
 135 0092 B601      		movw r22,r12
 136 0094 0E94 0000 		call __gesf2
 137               	.LVL5:
 138 0098 87FD      		sbrc r24,7
 139 009a 00C0      		rjmp .L1
 140               	.LVL6:
 141               	.LBB12:
 142               	.LBB13:
 207:blockhead.c   **** 		the_block->y = -the_block->height;
 143               		.loc 1 207 0
 144 009c 6989      		ldd r22,Y+17
 145 009e 70E0      		ldi r23,0
 146 00a0 7195      		neg r23
 147 00a2 6195      		neg r22
 148 00a4 7109      		sbc r23,__zero_reg__
 149 00a6 072E      		mov __tmp_reg__,r23
 150 00a8 000C      		lsl r0
 151 00aa 880B      		sbc r24,r24
 152 00ac 990B      		sbc r25,r25
 153 00ae 0E94 0000 		call __floatsisf
 154               	.LVL7:
 155 00b2 6C83      		std Y+4,r22
 156 00b4 7D83      		std Y+5,r23
 157 00b6 8E83      		std Y+6,r24
 158 00b8 9F83      		std Y+7,r25
 159               	.LVL8:
 160               	.L1:
 161               	/* epilogue start */
 162               	.LBE13:
 163               	.LBE12:
 208:blockhead.c   **** 	}
 209:blockhead.c   **** }
 164               		.loc 1 209 0
 165 00ba DF91      		pop r29
 166 00bc CF91      		pop r28
 167               	.LVL9:
 168 00be FF90      		pop r15
 169 00c0 EF90      		pop r14
 170 00c2 DF90      		pop r13
 171 00c4 CF90      		pop r12
 172 00c6 BF90      		pop r11
 173 00c8 AF90      		pop r10
 174 00ca 9F90      		pop r9
 175 00cc 8F90      		pop r8
 176 00ce 0895      		ret
 177               		.cfi_endproc
 178               	.LFE9:
 180               		.section	.text.do_the_walk,"ax",@progbits
 181               	.global	do_the_walk
 183               	do_the_walk:
 184               	.LFB8:
  41:blockhead.c   **** 	// Notes: 
 185               		.loc 1 41 0
 186               		.cfi_startproc
 187 0000 AF92      		push r10
 188               	.LCFI10:
 189               		.cfi_def_cfa_offset 3
 190               		.cfi_offset 10, -2
 191 0002 BF92      		push r11
 192               	.LCFI11:
 193               		.cfi_def_cfa_offset 4
 194               		.cfi_offset 11, -3
 195 0004 CF92      		push r12
 196               	.LCFI12:
 197               		.cfi_def_cfa_offset 5
 198               		.cfi_offset 12, -4
 199 0006 DF92      		push r13
 200               	.LCFI13:
 201               		.cfi_def_cfa_offset 6
 202               		.cfi_offset 13, -5
 203 0008 EF92      		push r14
 204               	.LCFI14:
 205               		.cfi_def_cfa_offset 7
 206               		.cfi_offset 14, -6
 207 000a FF92      		push r15
 208               	.LCFI15:
 209               		.cfi_def_cfa_offset 8
 210               		.cfi_offset 15, -7
 211 000c 0F93      		push r16
 212               	.LCFI16:
 213               		.cfi_def_cfa_offset 9
 214               		.cfi_offset 16, -8
 215 000e 1F93      		push r17
 216               	.LCFI17:
 217               		.cfi_def_cfa_offset 10
 218               		.cfi_offset 17, -9
 219 0010 CF93      		push r28
 220               	.LCFI18:
 221               		.cfi_def_cfa_offset 11
 222               		.cfi_offset 28, -10
 223 0012 DF93      		push r29
 224               	.LCFI19:
 225               		.cfi_def_cfa_offset 12
 226               		.cfi_offset 29, -11
 227 0014 CDB7      		in r28,__SP_L__
 228 0016 DEB7      		in r29,__SP_H__
 229               	.LCFI20:
 230               		.cfi_def_cfa_register 28
 231 0018 6597      		sbiw r28,21
 232               	.LCFI21:
 233               		.cfi_def_cfa_offset 33
 234 001a 0FB6      		in __tmp_reg__,__SREG__
 235 001c F894      		cli
 236 001e DEBF      		out __SP_H__,r29
 237 0020 0FBE      		out __SREG__,__tmp_reg__
 238 0022 CDBF      		out __SP_L__,r28
 239               	/* prologue: function */
 240               	/* frame size = 21 */
 241               	/* stack size = 31 */
 242               	.L__stack_usage = 31
 243               	.LVL10:
 166:blockhead.c   **** 	blockhead.dx = 1;
 244               		.loc 1 166 0
 245 0024 20E0      		ldi r18,lo8(bitmap0.1886)
 246 0026 A22E      		mov r10,r18
 247 0028 20E0      		ldi r18,hi8(bitmap0.1886)
 248 002a B22E      		mov r11,r18
 249 002c 34E1      		ldi r19,lo8(20)
 250 002e C32E      		mov r12,r19
 251 0030 4DE0      		ldi r20,lo8(13)
 252 0032 E42E      		mov r14,r20
 253 0034 00E0      		ldi r16,0
 254 0036 10E0      		ldi r17,0
 255 0038 20E6      		ldi r18,lo8(96)
 256 003a 31E4      		ldi r19,lo8(65)
 257 003c 40E0      		ldi r20,0
 258 003e 50E0      		ldi r21,0
 259 0040 6CE0      		ldi r22,lo8(12)
 260 0042 72E4      		ldi r23,lo8(66)
 261 0044 CE01      		movw r24,r28
 262 0046 0196      		adiw r24,1
 263 0048 0E94 0000 		call init_sprite
 264               	.LVL11:
 167:blockhead.c   **** 	blockhead.dy = 0;
 265               		.loc 1 167 0
 266 004c 80E0      		ldi r24,0
 267 004e 90E0      		ldi r25,0
 268 0050 A0E8      		ldi r26,lo8(-128)
 269 0052 BFE3      		ldi r27,lo8(63)
 270 0054 8987      		std Y+9,r24
 271 0056 9A87      		std Y+10,r25
 272 0058 AB87      		std Y+11,r26
 273 005a BC87      		std Y+12,r27
 168:blockhead.c   **** 
 274               		.loc 1 168 0
 275 005c 1D86      		std Y+13,__zero_reg__
 276 005e 1E86      		std Y+14,__zero_reg__
 277 0060 1F86      		std Y+15,__zero_reg__
 278 0062 188A      		std Y+16,__zero_reg__
 170:blockhead.c   **** 	draw_sprite( &blockhead );
 279               		.loc 1 170 0
 280 0064 0E94 0000 		call clear_screen
 281               	.LVL12:
 171:blockhead.c   **** 	show_screen();
 282               		.loc 1 171 0
 283 0068 CE01      		movw r24,r28
 284 006a 0196      		adiw r24,1
 285 006c 0E94 0000 		call draw_sprite
 286               	.LVL13:
 172:blockhead.c   **** 
 287               		.loc 1 172 0
 288 0070 0E94 0000 		call show_screen
 289               	.LVL14:
 174:blockhead.c   **** 
 290               		.loc 1 174 0
 291 0074 2A9A      		sbi 0x5,2
 292               	.L9:
 174:blockhead.c   **** 
 293               		.loc 1 174 0 is_stmt 0 discriminator 2
 294 0076 7E9B      		sbis 0xf,6
 295 0078 00C0      		rjmp .L9
 296               	.LVL15:
 297               	.LBB14:
 298               	.LBB15:
 299               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 300               		.loc 2 187 0 is_stmt 1
 301 007a 2FEF      		ldi r18,lo8(159999)
 302 007c 80E7      		ldi r24,hi8(159999)
 303 007e 92E0      		ldi r25,hlo8(159999)
 304 0080 2150      	1:	subi r18,1
 305 0082 8040      		sbci r24,0
 306 0084 9040      		sbci r25,0
 307 0086 01F4      		brne 1b
 308 0088 00C0      		rjmp .
 309 008a 0000      		nop
 310               	.LVL16:
 311               	.LBE15:
 312               	.LBE14:
 174:blockhead.c   **** 
 313               		.loc 1 174 0
 314 008c 2A98      		cbi 0x5,2
 315               	.LVL17:
 179:blockhead.c   **** 	while ( !pressed( SW2 ) ) {
 316               		.loc 1 179 0
 317 008e 2A9A      		sbi 0x5,2
 177:blockhead.c   **** 
 318               		.loc 1 177 0
 319 0090 E12C      		mov r14,__zero_reg__
 320 0092 F12C      		mov r15,__zero_reg__
 176:blockhead.c   **** 	int walk_counter = 0;
 321               		.loc 1 176 0
 322 0094 00E0      		ldi r16,0
 323 0096 10E0      		ldi r17,0
 184:blockhead.c   **** 			current_image++;
 324               		.loc 1 184 0
 325 0098 9AE0      		ldi r25,lo8(10)
 326 009a C92E      		mov r12,r25
 327 009c D12C      		mov r13,__zero_reg__
 328               	.LVL18:
 329               	.L10:
 180:blockhead.c   **** 		clear_screen();
 330               		.loc 1 180 0
 331 009e 7D9B      		sbis 0xf,5
 332 00a0 00C0      		rjmp .L12
 333               	/* epilogue start */
 196:blockhead.c   **** 
 334               		.loc 1 196 0
 335 00a2 6596      		adiw r28,21
 336 00a4 0FB6      		in __tmp_reg__,__SREG__
 337 00a6 F894      		cli
 338 00a8 DEBF      		out __SP_H__,r29
 339 00aa 0FBE      		out __SREG__,__tmp_reg__
 340 00ac CDBF      		out __SP_L__,r28
 341 00ae DF91      		pop r29
 342 00b0 CF91      		pop r28
 343 00b2 1F91      		pop r17
 344 00b4 0F91      		pop r16
 345               	.LVL19:
 346 00b6 FF90      		pop r15
 347 00b8 EF90      		pop r14
 348               	.LVL20:
 349 00ba DF90      		pop r13
 350 00bc CF90      		pop r12
 351 00be BF90      		pop r11
 352 00c0 AF90      		pop r10
 353 00c2 0895      		ret
 354               	.LVL21:
 355               	.L12:
 181:blockhead.c   **** 		walk_counter++;
 356               		.loc 1 181 0
 357 00c4 0E94 0000 		call clear_screen
 358               	.LVL22:
 182:blockhead.c   **** 
 359               		.loc 1 182 0
 360 00c8 2FEF      		ldi r18,-1
 361 00ca E21A      		sub r14,r18
 362 00cc F20A      		sbc r15,r18
 363               	.LVL23:
 184:blockhead.c   **** 			current_image++;
 364               		.loc 1 184 0
 365 00ce C701      		movw r24,r14
 366 00d0 B601      		movw r22,r12
 367 00d2 0E94 0000 		call __divmodhi4
 368 00d6 892B      		or r24,r25
 369 00d8 01F4      		brne .L11
 185:blockhead.c   **** 			current_image %= BITMAP_COUNT;
 370               		.loc 1 185 0
 371 00da 0F5F      		subi r16,-1
 372 00dc 1F4F      		sbci r17,-1
 373               	.LVL24:
 186:blockhead.c   **** 			blockhead.bitmap = bitmaps[current_image];
 374               		.loc 1 186 0
 375 00de 0370      		andi r16,3
 376 00e0 1127      		clr r17
 377               	.LVL25:
 187:blockhead.c   **** 		}
 378               		.loc 1 187 0
 379 00e2 F801      		movw r30,r16
 380 00e4 EE0F      		lsl r30
 381 00e6 FF1F      		rol r31
 382 00e8 E050      		subi r30,lo8(-(bitmaps.1891))
 383 00ea F040      		sbci r31,hi8(-(bitmaps.1891))
 384 00ec 8081      		ld r24,Z
 385 00ee 9181      		ldd r25,Z+1
 386 00f0 9D8B      		std Y+21,r25
 387 00f2 8C8B      		std Y+20,r24
 388               	.L11:
 190:blockhead.c   **** 		
 389               		.loc 1 190 0
 390 00f4 CE01      		movw r24,r28
 391 00f6 0196      		adiw r24,1
 392 00f8 0E94 0000 		call update_blockhead
 393               	.LVL26:
 192:blockhead.c   **** 		show_screen();
 394               		.loc 1 192 0
 395 00fc CE01      		movw r24,r28
 396 00fe 0196      		adiw r24,1
 397 0100 0E94 0000 		call draw_sprite
 398               	.LVL27:
 193:blockhead.c   **** 		_delay_ms( 20 );
 399               		.loc 1 193 0
 400 0104 0E94 0000 		call show_screen
 401               	.LVL28:
 402               	.LBB16:
 403               	.LBB17:
 404               		.loc 2 187 0
 405 0108 8FE3      		ldi r24,lo8(-25537)
 406 010a 9CE9      		ldi r25,hi8(-25537)
 407 010c 0197      	1:	sbiw r24,1
 408 010e 01F4      		brne 1b
 409 0110 00C0      		rjmp .
 410 0112 0000      		nop
 411 0114 00C0      		rjmp .L10
 412               	.LBE17:
 413               	.LBE16:
 414               		.cfi_endproc
 415               	.LFE8:
 417               		.section	.rodata.str1.1,"aMS",@progbits,1
 418               	.LC0:
 419 0000 436C 6963 		.string	"Click to walk..."
 419      6B20 746F 
 419      2077 616C 
 419      6B2E 2E2E 
 419      00
 420               	.LC1:
 421 0011 5761 6C6B 		.string	"Walk over."
 421      206F 7665 
 421      722E 00
 422               	.LC2:
 423 001c 436C 6963 		.string	"Click to exit..."
 423      6B20 746F 
 423      2065 7869 
 423      742E 2E2E 
 423      00
 424               		.section	.text.walk_the_walk,"ax",@progbits
 425               	.global	walk_the_walk
 427               	walk_the_walk:
 428               	.LFB7:
  18:blockhead.c   **** 	clear_screen();
 429               		.loc 1 18 0
 430               		.cfi_startproc
 431               	/* prologue: function */
 432               	/* frame size = 0 */
 433               	/* stack size = 0 */
 434               	.L__stack_usage = 0
  19:blockhead.c   **** 	turn_on( LED1 );
 435               		.loc 1 19 0
 436 0000 0E94 0000 		call clear_screen
 437               	.LVL29:
  20:blockhead.c   **** 	draw_string( 0, 0, "Click to walk..." );
 438               		.loc 1 20 0
 439 0004 2B9A      		sbi 0x5,3
  21:blockhead.c   **** 	show_screen();
 440               		.loc 1 21 0
 441 0006 40E0      		ldi r20,lo8(.LC0)
 442 0008 50E0      		ldi r21,hi8(.LC0)
 443 000a 60E0      		ldi r22,0
 444 000c 80E0      		ldi r24,0
 445 000e 0E94 0000 		call draw_string
 446               	.LVL30:
  22:blockhead.c   **** 	wait_until( pressed( SW2 ) );
 447               		.loc 1 22 0
 448 0012 0E94 0000 		call show_screen
 449               	.LVL31:
 450               	.L16:
  23:blockhead.c   **** 	_delay_ms(100);
 451               		.loc 1 23 0 discriminator 1
 452 0016 7D9B      		sbis 0xf,5
 453 0018 00C0      		rjmp .L16
 454               	.LVL32:
 455               	.LBB18:
 456               	.LBB19:
 457               		.loc 2 187 0
 458 001a 2FEF      		ldi r18,lo8(159999)
 459 001c 80E7      		ldi r24,hi8(159999)
 460 001e 92E0      		ldi r25,hlo8(159999)
 461 0020 2150      	1:	subi r18,1
 462 0022 8040      		sbci r24,0
 463 0024 9040      		sbci r25,0
 464 0026 01F4      		brne 1b
 465 0028 00C0      		rjmp .
 466 002a 0000      		nop
 467               	.L17:
 468               	.LBE19:
 469               	.LBE18:
  25:blockhead.c   **** 	turn_off( LED1 );
 470               		.loc 1 25 0 discriminator 1
 471 002c 7D99      		sbic 0xf,5
 472 002e 00C0      		rjmp .L17
  26:blockhead.c   **** 
 473               		.loc 1 26 0
 474 0030 2B98      		cbi 0x5,3
  28:blockhead.c   **** 
 475               		.loc 1 28 0
 476 0032 0E94 0000 		call do_the_walk
 477               	.LVL33:
  30:blockhead.c   **** 	turn_on( LED1 );
 478               		.loc 1 30 0
 479 0036 0E94 0000 		call clear_screen
 480               	.LVL34:
  31:blockhead.c   **** 	draw_string( 0, 0, "Walk over." );
 481               		.loc 1 31 0
 482 003a 2B9A      		sbi 0x5,3
  32:blockhead.c   **** 	draw_string( 0, 8, "Click to exit..." );
 483               		.loc 1 32 0
 484 003c 40E0      		ldi r20,lo8(.LC1)
 485 003e 50E0      		ldi r21,hi8(.LC1)
 486 0040 60E0      		ldi r22,0
 487 0042 80E0      		ldi r24,0
 488 0044 0E94 0000 		call draw_string
 489               	.LVL35:
  33:blockhead.c   **** 	show_screen();
 490               		.loc 1 33 0
 491 0048 40E0      		ldi r20,lo8(.LC2)
 492 004a 50E0      		ldi r21,hi8(.LC2)
 493 004c 68E0      		ldi r22,lo8(8)
 494 004e 80E0      		ldi r24,0
 495 0050 0E94 0000 		call draw_string
 496               	.LVL36:
  34:blockhead.c   **** 	wait_until( pressed( SW2 ) );
 497               		.loc 1 34 0
 498 0054 0E94 0000 		call show_screen
 499               	.LVL37:
 500               	.L18:
  35:blockhead.c   **** 	_delay_ms(100);
 501               		.loc 1 35 0 discriminator 1
 502 0058 7D9B      		sbis 0xf,5
 503 005a 00C0      		rjmp .L18
 504               	.LVL38:
 505               	.LBB20:
 506               	.LBB21:
 507               		.loc 2 187 0
 508 005c 2FEF      		ldi r18,lo8(159999)
 509 005e 80E7      		ldi r24,hi8(159999)
 510 0060 92E0      		ldi r25,hlo8(159999)
 511 0062 2150      	1:	subi r18,1
 512 0064 8040      		sbci r24,0
 513 0066 9040      		sbci r25,0
 514 0068 01F4      		brne 1b
 515 006a 00C0      		rjmp .
 516 006c 0000      		nop
 517               	.L19:
 518               	.LBE21:
 519               	.LBE20:
  37:blockhead.c   **** 	turn_off( LED1 );
 520               		.loc 1 37 0 discriminator 1
 521 006e 7D99      		sbic 0xf,5
 522 0070 00C0      		rjmp .L19
  38:blockhead.c   **** }
 523               		.loc 1 38 0
 524 0072 2B98      		cbi 0x5,3
 525 0074 0895      		ret
 526               		.cfi_endproc
 527               	.LFE7:
 529               		.data
 532               	bitmap3.1887:
 533 0000 0F        		.byte	15
 534 0001 80        		.byte	-128
 535 0002 08        		.byte	8
 536 0003 80        		.byte	-128
 537 0004 08        		.byte	8
 538 0005 80        		.byte	-128
 539 0006 0F        		.byte	15
 540 0007 80        		.byte	-128
 541 0008 02        		.byte	2
 542 0009 00        		.byte	0
 543 000a 07        		.byte	7
 544 000b 00        		.byte	0
 545 000c 0A        		.byte	10
 546 000d 80        		.byte	-128
 547 000e 12        		.byte	18
 548 000f 80        		.byte	-128
 549 0010 12        		.byte	18
 550 0011 40        		.byte	64
 551 0012 12        		.byte	18
 552 0013 20        		.byte	32
 553 0014 02        		.byte	2
 554 0015 00        		.byte	0
 555 0016 03        		.byte	3
 556 0017 00        		.byte	0
 557 0018 02        		.byte	2
 558 0019 C0        		.byte	-64
 559 001a 02        		.byte	2
 560 001b 20        		.byte	32
 561 001c 02        		.byte	2
 562 001d C0        		.byte	-64
 563 001e 03        		.byte	3
 564 001f 00        		.byte	0
 565 0020 0E        		.byte	14
 566 0021 00        		.byte	0
 567 0022 12        		.byte	18
 568 0023 00        		.byte	0
 569 0024 12        		.byte	18
 570 0025 00        		.byte	0
 571 0026 03        		.byte	3
 572 0027 80        		.byte	-128
 575               	bitmap4.1888:
 576 0028 07        		.byte	7
 577 0029 C0        		.byte	-64
 578 002a 04        		.byte	4
 579 002b 40        		.byte	64
 580 002c 04        		.byte	4
 581 002d 40        		.byte	64
 582 002e 07        		.byte	7
 583 002f C0        		.byte	-64
 584 0030 01        		.byte	1
 585 0031 00        		.byte	0
 586 0032 03        		.byte	3
 587 0033 80        		.byte	-128
 588 0034 0D        		.byte	13
 589 0035 40        		.byte	64
 590 0036 31        		.byte	49
 591 0037 20        		.byte	32
 592 0038 12        		.byte	18
 593 0039 18        		.byte	24
 594 003a 04        		.byte	4
 595 003b 00        		.byte	0
 596 003c 04        		.byte	4
 597 003d 00        		.byte	0
 598 003e 07        		.byte	7
 599 003f 00        		.byte	0
 600 0040 04        		.byte	4
 601 0041 C0        		.byte	-64
 602 0042 02        		.byte	2
 603 0043 30        		.byte	48
 604 0044 01        		.byte	1
 605 0045 08        		.byte	8
 606 0046 01        		.byte	1
 607 0047 10        		.byte	16
 608 0048 01        		.byte	1
 609 0049 20        		.byte	32
 610 004a 02        		.byte	2
 611 004b 38        		.byte	56
 612 004c 04        		.byte	4
 613 004d 00        		.byte	0
 614 004e 0E        		.byte	14
 615 004f 00        		.byte	0
 618               	bitmap1.1889:
 619 0050 0F        		.byte	15
 620 0051 80        		.byte	-128
 621 0052 08        		.byte	8
 622 0053 80        		.byte	-128
 623 0054 08        		.byte	8
 624 0055 80        		.byte	-128
 625 0056 0F        		.byte	15
 626 0057 80        		.byte	-128
 627 0058 02        		.byte	2
 628 0059 00        		.byte	0
 629 005a 07        		.byte	7
 630 005b 00        		.byte	0
 631 005c 0A        		.byte	10
 632 005d 80        		.byte	-128
 633 005e 12        		.byte	18
 634 005f 80        		.byte	-128
 635 0060 12        		.byte	18
 636 0061 40        		.byte	64
 637 0062 12        		.byte	18
 638 0063 20        		.byte	32
 639 0064 02        		.byte	2
 640 0065 00        		.byte	0
 641 0066 07        		.byte	7
 642 0067 00        		.byte	0
 643 0068 05        		.byte	5
 644 0069 00        		.byte	0
 645 006a 04        		.byte	4
 646 006b 80        		.byte	-128
 647 006c 08        		.byte	8
 648 006d 40        		.byte	64
 649 006e 08        		.byte	8
 650 006f 20        		.byte	32
 651 0070 10        		.byte	16
 652 0071 20        		.byte	32
 653 0072 10        		.byte	16
 654 0073 20        		.byte	32
 655 0074 20        		.byte	32
 656 0075 20        		.byte	32
 657 0076 38        		.byte	56
 658 0077 38        		.byte	56
 661               	bitmap2.1890:
 662 0078 03        		.byte	3
 663 0079 E0        		.byte	-32
 664 007a 02        		.byte	2
 665 007b 20        		.byte	32
 666 007c 02        		.byte	2
 667 007d 20        		.byte	32
 668 007e 03        		.byte	3
 669 007f E0        		.byte	-32
 670 0080 00        		.byte	0
 671 0081 80        		.byte	-128
 672 0082 01        		.byte	1
 673 0083 C0        		.byte	-64
 674 0084 06        		.byte	6
 675 0085 A0        		.byte	-96
 676 0086 18        		.byte	24
 677 0087 90        		.byte	-112
 678 0088 08        		.byte	8
 679 0089 98        		.byte	-104
 680 008a 01        		.byte	1
 681 008b 00        		.byte	0
 682 008c 01        		.byte	1
 683 008d 00        		.byte	0
 684 008e 03        		.byte	3
 685 008f 80        		.byte	-128
 686 0090 02        		.byte	2
 687 0091 40        		.byte	64
 688 0092 02        		.byte	2
 689 0093 20        		.byte	32
 690 0094 02        		.byte	2
 691 0095 10        		.byte	16
 692 0096 02        		.byte	2
 693 0097 08        		.byte	8
 694 0098 0C        		.byte	12
 695 0099 10        		.byte	16
 696 009a 30        		.byte	48
 697 009b 10        		.byte	16
 698 009c 20        		.byte	32
 699 009d 20        		.byte	32
 700 009e 00        		.byte	0
 701 009f 38        		.byte	56
 702               		.section	.rodata
 705               	bitmaps.1891:
 706 0000 0000      		.word	bitmap1.1889
 707 0002 0000      		.word	bitmap2.1890
 708 0004 0000      		.word	bitmap3.1887
 709 0006 0000      		.word	bitmap4.1888
 710               		.data
 713               	bitmap0.1886:
 714 00a0 0F        		.byte	15
 715 00a1 80        		.byte	-128
 716 00a2 08        		.byte	8
 717 00a3 80        		.byte	-128
 718 00a4 08        		.byte	8
 719 00a5 80        		.byte	-128
 720 00a6 0F        		.byte	15
 721 00a7 80        		.byte	-128
 722 00a8 02        		.byte	2
 723 00a9 00        		.byte	0
 724 00aa 0F        		.byte	15
 725 00ab 80        		.byte	-128
 726 00ac 12        		.byte	18
 727 00ad 40        		.byte	64
 728 00ae 22        		.byte	34
 729 00af 20        		.byte	32
 730 00b0 42        		.byte	66
 731 00b1 10        		.byte	16
 732 00b2 82        		.byte	-126
 733 00b3 08        		.byte	8
 734 00b4 02        		.byte	2
 735 00b5 00        		.byte	0
 736 00b6 05        		.byte	5
 737 00b7 00        		.byte	0
 738 00b8 08        		.byte	8
 739 00b9 80        		.byte	-128
 740 00ba 08        		.byte	8
 741 00bb 80        		.byte	-128
 742 00bc 08        		.byte	8
 743 00bd 80        		.byte	-128
 744 00be 10        		.byte	16
 745 00bf 40        		.byte	64
 746 00c0 10        		.byte	16
 747 00c1 40        		.byte	64
 748 00c2 20        		.byte	32
 749 00c3 20        		.byte	32
 750 00c4 20        		.byte	32
 751 00c5 20        		.byte	32
 752 00c6 E0        		.byte	-32
 753 00c7 38        		.byte	56
 754               		.text
 755               	.Letext0:
 756               		.file 3 "/usr/avr/include/stdint.h"
 757               		.file 4 "byte.h"
 758               		.file 5 "../cab202_teensy/sprite.h"
 759               		.file 6 "../cab202_teensy/ascii_font.h"
 760               		.file 7 "../cab202_teensy/graphics.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 blockhead.c
     /tmp/cc9r3m0A.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc9r3m0A.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc9r3m0A.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc9r3m0A.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc9r3m0A.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc9r3m0A.s:16     .text.update_blockhead:0000000000000000 update_blockhead
     /tmp/cc9r3m0A.s:183    .text.do_the_walk:0000000000000000 do_the_walk
     /tmp/cc9r3m0A.s:713    .data:00000000000000a0 bitmap0.1886
     /tmp/cc9r3m0A.s:705    .rodata:0000000000000000 bitmaps.1891
     /tmp/cc9r3m0A.s:427    .text.walk_the_walk:0000000000000000 walk_the_walk
     /tmp/cc9r3m0A.s:532    .data:0000000000000000 bitmap3.1887
     /tmp/cc9r3m0A.s:575    .data:0000000000000028 bitmap4.1888
     /tmp/cc9r3m0A.s:618    .data:0000000000000050 bitmap1.1889
     /tmp/cc9r3m0A.s:661    .data:0000000000000078 bitmap2.1890

UNDEFINED SYMBOLS
__addsf3
__gesf2
__floatsisf
init_sprite
clear_screen
draw_sprite
show_screen
__divmodhi4
draw_string
__do_copy_data
