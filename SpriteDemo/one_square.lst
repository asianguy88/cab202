   1               		.file	"one_square.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	__addsf3
  11               	.global	__floatsisf
  12               	.global	__gesf2
  13               	.global	__ltsf2
  14               		.section	.text.update_one_square,"ax",@progbits
  15               	.global	update_one_square
  17               	update_one_square:
  18               	.LFB13:
  19               		.file 1 "one_square.c"
   1:one_square.c  **** /*
   2:one_square.c  **** *	File:	one_square.c
   3:one_square.c  **** *	Author: Lawrence Buckingham, Queensland University of Technology.
   4:one_square.c  **** *	Date:	27 April 2015.
   5:one_square.c  **** *
   6:one_square.c  **** *	Implementation of the functions provided by the one_square "game".
   7:one_square.c  **** */
   8:one_square.c  **** 
   9:one_square.c  **** #include <stdlib.h>
  10:one_square.c  **** #include <stdio.h>
  11:one_square.c  **** #include <math.h>
  12:one_square.c  **** #include <util/delay.h>
  13:one_square.c  **** #include "byte.h"
  14:one_square.c  **** #include "one_square.h"
  15:one_square.c  **** #include "sprite.h"
  16:one_square.c  **** #include "friendly_ports.h"
  17:one_square.c  **** #include "graphics.h"
  18:one_square.c  **** 
  19:one_square.c  **** void update_one_square( Sprite * sprite );
  20:one_square.c  **** 
  21:one_square.c  **** void play_one_square() {
  22:one_square.c  **** 	clear_screen();
  23:one_square.c  **** 	draw_string( 0, 0, "Click right" );
  24:one_square.c  **** 	draw_string( 0, 8, "to play" );
  25:one_square.c  **** 	show_screen();
  26:one_square.c  **** 	wait_until( pressed( SW2 ) );
  27:one_square.c  **** 	_delay_ms(50);
  28:one_square.c  **** 	wait_until( !pressed( SW2 ) );
  29:one_square.c  **** 
  30:one_square.c  **** 	_delay_ms( 500 );
  31:one_square.c  **** 
  32:one_square.c  **** 	// Notes: 
  33:one_square.c  **** 	//	byte is typedef name for unsigned char, defined in byte.h
  34:one_square.c  **** 	//	UINT and BYTE macros provide a standards-compliant way to express
  35:one_square.c  **** 	//	a binary literal ... the 0b00000000 notation supported by gcc is
  36:one_square.c  **** 	//	not defined in the Standard C language.
  37:one_square.c  **** 
  38:one_square.c  **** 	static byte bitmap [] = {
  39:one_square.c  **** 		BYTE( 11111111 ),
  40:one_square.c  **** 		BYTE( 10000001 ),
  41:one_square.c  **** 		BYTE( 10000001 ),
  42:one_square.c  **** 		BYTE( 10000001 ),
  43:one_square.c  **** 		BYTE( 10000001 ),
  44:one_square.c  **** 		BYTE( 10000001 ),
  45:one_square.c  **** 		BYTE( 10000001 ),
  46:one_square.c  **** 		BYTE( 11111111 )
  47:one_square.c  **** 	};
  48:one_square.c  **** 
  49:one_square.c  **** 	Sprite sprite;
  50:one_square.c  **** 
  51:one_square.c  **** 	init_sprite( &sprite, 0, 0, 8, 8, bitmap );
  52:one_square.c  **** 	srandom( 5198985 );
  53:one_square.c  **** 	double angle = ((double)random()) * 2 * M_PI / RANDOM_MAX;
  54:one_square.c  **** 	sprite.dx = cos( angle );
  55:one_square.c  **** 	sprite.dy = sin( angle );
  56:one_square.c  **** 
  57:one_square.c  **** 	while ( ! pressed( SW2 ) ) {
  58:one_square.c  **** 		clear_screen();
  59:one_square.c  **** 		update_one_square( & sprite );
  60:one_square.c  **** 		draw_sprite( &sprite );
  61:one_square.c  **** 		show_screen();
  62:one_square.c  **** 		_delay_ms( 20 );
  63:one_square.c  **** 	}
  64:one_square.c  **** 
  65:one_square.c  **** 	clear_screen();
  66:one_square.c  **** 	draw_string( 0, 0, "Game Over" );
  67:one_square.c  **** 	show_screen();
  68:one_square.c  **** 
  69:one_square.c  **** 	db_wait();
  70:one_square.c  **** }
  71:one_square.c  **** 
  72:one_square.c  **** void update_one_square( Sprite * sprite ) {
  20               		.loc 1 72 0
  21               		.cfi_startproc
  22               	.LVL0:
  23 0000 4F92      		push r4
  24               	.LCFI0:
  25               		.cfi_def_cfa_offset 3
  26               		.cfi_offset 4, -2
  27 0002 5F92      		push r5
  28               	.LCFI1:
  29               		.cfi_def_cfa_offset 4
  30               		.cfi_offset 5, -3
  31 0004 6F92      		push r6
  32               	.LCFI2:
  33               		.cfi_def_cfa_offset 5
  34               		.cfi_offset 6, -4
  35 0006 7F92      		push r7
  36               	.LCFI3:
  37               		.cfi_def_cfa_offset 6
  38               		.cfi_offset 7, -5
  39 0008 8F92      		push r8
  40               	.LCFI4:
  41               		.cfi_def_cfa_offset 7
  42               		.cfi_offset 8, -6
  43 000a 9F92      		push r9
  44               	.LCFI5:
  45               		.cfi_def_cfa_offset 8
  46               		.cfi_offset 9, -7
  47 000c AF92      		push r10
  48               	.LCFI6:
  49               		.cfi_def_cfa_offset 9
  50               		.cfi_offset 10, -8
  51 000e BF92      		push r11
  52               	.LCFI7:
  53               		.cfi_def_cfa_offset 10
  54               		.cfi_offset 11, -9
  55 0010 CF92      		push r12
  56               	.LCFI8:
  57               		.cfi_def_cfa_offset 11
  58               		.cfi_offset 12, -10
  59 0012 DF92      		push r13
  60               	.LCFI9:
  61               		.cfi_def_cfa_offset 12
  62               		.cfi_offset 13, -11
  63 0014 EF92      		push r14
  64               	.LCFI10:
  65               		.cfi_def_cfa_offset 13
  66               		.cfi_offset 14, -12
  67 0016 FF92      		push r15
  68               	.LCFI11:
  69               		.cfi_def_cfa_offset 14
  70               		.cfi_offset 15, -13
  71 0018 0F93      		push r16
  72               	.LCFI12:
  73               		.cfi_def_cfa_offset 15
  74               		.cfi_offset 16, -14
  75 001a 1F93      		push r17
  76               	.LCFI13:
  77               		.cfi_def_cfa_offset 16
  78               		.cfi_offset 17, -15
  79 001c CF93      		push r28
  80               	.LCFI14:
  81               		.cfi_def_cfa_offset 17
  82               		.cfi_offset 28, -16
  83 001e DF93      		push r29
  84               	.LCFI15:
  85               		.cfi_def_cfa_offset 18
  86               		.cfi_offset 29, -17
  87 0020 00D0      		rcall .
  88 0022 00D0      		rcall .
  89               	.LCFI16:
  90               		.cfi_def_cfa_offset 22
  91 0024 CDB7      		in r28,__SP_L__
  92 0026 DEB7      		in r29,__SP_H__
  93               	.LCFI17:
  94               		.cfi_def_cfa_register 28
  95               	/* prologue: function */
  96               	/* frame size = 4 */
  97               	/* stack size = 20 */
  98               	.L__stack_usage = 20
  99 0028 8C01      		movw r16,r24
  73:one_square.c  **** 	sprite->x += sprite->dx;
 100               		.loc 1 73 0
 101 002a DC01      		movw r26,r24
 102 002c 1896      		adiw r26,8
 103 002e CD90      		ld r12,X+
 104 0030 DD90      		ld r13,X+
 105 0032 ED90      		ld r14,X+
 106 0034 FC90      		ld r15,X
 107 0036 1B97      		sbiw r26,8+3
 108 0038 2D91      		ld r18,X+
 109 003a 3D91      		ld r19,X+
 110 003c 4D91      		ld r20,X+
 111 003e 5C91      		ld r21,X
 112 0040 C701      		movw r24,r14
 113 0042 B601      		movw r22,r12
 114 0044 0E94 0000 		call __addsf3
 115               	.LVL1:
 116 0048 2B01      		movw r4,r22
 117 004a 3C01      		movw r6,r24
 118 004c F801      		movw r30,r16
 119 004e 6083      		st Z,r22
 120 0050 7183      		std Z+1,r23
 121 0052 8283      		std Z+2,r24
 122 0054 9383      		std Z+3,r25
  74:one_square.c  **** 	sprite->y += sprite->dy;
 123               		.loc 1 74 0
 124 0056 8485      		ldd r24,Z+12
 125 0058 9585      		ldd r25,Z+13
 126 005a A685      		ldd r26,Z+14
 127 005c B785      		ldd r27,Z+15
 128 005e 8983      		std Y+1,r24
 129 0060 9A83      		std Y+2,r25
 130 0062 AB83      		std Y+3,r26
 131 0064 BC83      		std Y+4,r27
 132 0066 2481      		ldd r18,Z+4
 133 0068 3581      		ldd r19,Z+5
 134 006a 4681      		ldd r20,Z+6
 135 006c 5781      		ldd r21,Z+7
 136 006e BC01      		movw r22,r24
 137 0070 CD01      		movw r24,r26
 138 0072 0E94 0000 		call __addsf3
 139               	.LVL2:
 140 0076 4B01      		movw r8,r22
 141 0078 5C01      		movw r10,r24
 142 007a D801      		movw r26,r16
 143 007c 1496      		adiw r26,4
 144 007e 6D93      		st X+,r22
 145 0080 7D93      		st X+,r23
 146 0082 8D93      		st X+,r24
 147 0084 9C93      		st X,r25
 148 0086 1797      		sbiw r26,4+3
  75:one_square.c  **** 
  76:one_square.c  **** 	if ( sprite->x >= LCD_X - sprite->width || sprite->x < 0 ) {
 149               		.loc 1 76 0
 150 0088 5096      		adiw r26,16
 151 008a 8C91      		ld r24,X
 152 008c 64E5      		ldi r22,lo8(84)
 153 008e 70E0      		ldi r23,0
 154 0090 681B      		sub r22,r24
 155 0092 7109      		sbc r23,__zero_reg__
 156 0094 072E      		mov __tmp_reg__,r23
 157 0096 000C      		lsl r0
 158 0098 880B      		sbc r24,r24
 159 009a 990B      		sbc r25,r25
 160 009c 0E94 0000 		call __floatsisf
 161               	.LVL3:
 162 00a0 9B01      		movw r18,r22
 163 00a2 AC01      		movw r20,r24
 164 00a4 C301      		movw r24,r6
 165 00a6 B201      		movw r22,r4
 166 00a8 0E94 0000 		call __gesf2
 167               	.LVL4:
 168 00ac 87FF      		sbrs r24,7
 169 00ae 00C0      		rjmp .L2
 170               		.loc 1 76 0 is_stmt 0 discriminator 1
 171 00b0 20E0      		ldi r18,0
 172 00b2 30E0      		ldi r19,0
 173 00b4 A901      		movw r20,r18
 174 00b6 C301      		movw r24,r6
 175 00b8 B201      		movw r22,r4
 176 00ba 0E94 0000 		call __ltsf2
 177               	.LVL5:
 178 00be 87FF      		sbrs r24,7
 179 00c0 00C0      		rjmp .L3
 180               	.L2:
  77:one_square.c  **** 		sprite->dx = -sprite->dx;
 181               		.loc 1 77 0 is_stmt 1
 182 00c2 F7FA      		bst r15,7
 183 00c4 F094      		com r15
 184 00c6 F7F8      		bld r15,7
 185 00c8 F094      		com r15
 186 00ca F801      		movw r30,r16
 187 00cc C086      		std Z+8,r12
 188 00ce D186      		std Z+9,r13
 189 00d0 E286      		std Z+10,r14
 190 00d2 F386      		std Z+11,r15
 191               	.L3:
  78:one_square.c  **** 	}
  79:one_square.c  **** 
  80:one_square.c  **** 	if ( sprite->y >= LCD_Y - sprite->height || sprite->y < 0 ) {
 192               		.loc 1 80 0
 193 00d4 D801      		movw r26,r16
 194 00d6 5196      		adiw r26,17
 195 00d8 8C91      		ld r24,X
 196 00da 60E3      		ldi r22,lo8(48)
 197 00dc 70E0      		ldi r23,0
 198 00de 681B      		sub r22,r24
 199 00e0 7109      		sbc r23,__zero_reg__
 200 00e2 072E      		mov __tmp_reg__,r23
 201 00e4 000C      		lsl r0
 202 00e6 880B      		sbc r24,r24
 203 00e8 990B      		sbc r25,r25
 204 00ea 0E94 0000 		call __floatsisf
 205               	.LVL6:
 206 00ee 9B01      		movw r18,r22
 207 00f0 AC01      		movw r20,r24
 208 00f2 C501      		movw r24,r10
 209 00f4 B401      		movw r22,r8
 210 00f6 0E94 0000 		call __gesf2
 211               	.LVL7:
 212 00fa 87FF      		sbrs r24,7
 213 00fc 00C0      		rjmp .L5
 214               		.loc 1 80 0 is_stmt 0 discriminator 1
 215 00fe 20E0      		ldi r18,0
 216 0100 30E0      		ldi r19,0
 217 0102 A901      		movw r20,r18
 218 0104 C501      		movw r24,r10
 219 0106 B401      		movw r22,r8
 220 0108 0E94 0000 		call __ltsf2
 221               	.LVL8:
 222 010c 87FF      		sbrs r24,7
 223 010e 00C0      		rjmp .L1
 224               	.L5:
  81:one_square.c  **** 		sprite->dy = -sprite->dy;
 225               		.loc 1 81 0 is_stmt 1
 226 0110 8981      		ldd r24,Y+1
 227 0112 9A81      		ldd r25,Y+2
 228 0114 AB81      		ldd r26,Y+3
 229 0116 BC81      		ldd r27,Y+4
 230 0118 B058      		subi r27,0x80
 231 011a F801      		movw r30,r16
 232 011c 8487      		std Z+12,r24
 233 011e 9587      		std Z+13,r25
 234 0120 A687      		std Z+14,r26
 235 0122 B787      		std Z+15,r27
 236               	.L1:
 237               	/* epilogue start */
  82:one_square.c  **** 	}
  83:one_square.c  **** }
 238               		.loc 1 83 0
 239 0124 0F90      		pop __tmp_reg__
 240 0126 0F90      		pop __tmp_reg__
 241 0128 0F90      		pop __tmp_reg__
 242 012a 0F90      		pop __tmp_reg__
 243 012c DF91      		pop r29
 244 012e CF91      		pop r28
 245 0130 1F91      		pop r17
 246 0132 0F91      		pop r16
 247               	.LVL9:
 248 0134 FF90      		pop r15
 249 0136 EF90      		pop r14
 250 0138 DF90      		pop r13
 251 013a CF90      		pop r12
 252 013c BF90      		pop r11
 253 013e AF90      		pop r10
 254 0140 9F90      		pop r9
 255 0142 8F90      		pop r8
 256 0144 7F90      		pop r7
 257 0146 6F90      		pop r6
 258 0148 5F90      		pop r5
 259 014a 4F90      		pop r4
 260 014c 0895      		ret
 261               		.cfi_endproc
 262               	.LFE13:
 264               		.section	.rodata.str1.1,"aMS",@progbits,1
 265               	.LC0:
 266 0000 436C 6963 		.string	"Click right"
 266      6B20 7269 
 266      6768 7400 
 267               	.LC1:
 268 000c 746F 2070 		.string	"to play"
 268      6C61 7900 
 269               	.global	__mulsf3
 270               	.LC2:
 271 0014 4761 6D65 		.string	"Game Over"
 271      204F 7665 
 271      7200 
 272               		.section	.text.play_one_square,"ax",@progbits
 273               	.global	play_one_square
 275               	play_one_square:
 276               	.LFB12:
  21:one_square.c  **** 	clear_screen();
 277               		.loc 1 21 0
 278               		.cfi_startproc
 279 0000 AF92      		push r10
 280               	.LCFI18:
 281               		.cfi_def_cfa_offset 3
 282               		.cfi_offset 10, -2
 283 0002 BF92      		push r11
 284               	.LCFI19:
 285               		.cfi_def_cfa_offset 4
 286               		.cfi_offset 11, -3
 287 0004 CF92      		push r12
 288               	.LCFI20:
 289               		.cfi_def_cfa_offset 5
 290               		.cfi_offset 12, -4
 291 0006 DF92      		push r13
 292               	.LCFI21:
 293               		.cfi_def_cfa_offset 6
 294               		.cfi_offset 13, -5
 295 0008 EF92      		push r14
 296               	.LCFI22:
 297               		.cfi_def_cfa_offset 7
 298               		.cfi_offset 14, -6
 299 000a FF92      		push r15
 300               	.LCFI23:
 301               		.cfi_def_cfa_offset 8
 302               		.cfi_offset 15, -7
 303 000c 0F93      		push r16
 304               	.LCFI24:
 305               		.cfi_def_cfa_offset 9
 306               		.cfi_offset 16, -8
 307 000e 1F93      		push r17
 308               	.LCFI25:
 309               		.cfi_def_cfa_offset 10
 310               		.cfi_offset 17, -9
 311 0010 CF93      		push r28
 312               	.LCFI26:
 313               		.cfi_def_cfa_offset 11
 314               		.cfi_offset 28, -10
 315 0012 DF93      		push r29
 316               	.LCFI27:
 317               		.cfi_def_cfa_offset 12
 318               		.cfi_offset 29, -11
 319 0014 CDB7      		in r28,__SP_L__
 320 0016 DEB7      		in r29,__SP_H__
 321               	.LCFI28:
 322               		.cfi_def_cfa_register 28
 323 0018 6597      		sbiw r28,21
 324               	.LCFI29:
 325               		.cfi_def_cfa_offset 33
 326 001a 0FB6      		in __tmp_reg__,__SREG__
 327 001c F894      		cli
 328 001e DEBF      		out __SP_H__,r29
 329 0020 0FBE      		out __SREG__,__tmp_reg__
 330 0022 CDBF      		out __SP_L__,r28
 331               	/* prologue: function */
 332               	/* frame size = 21 */
 333               	/* stack size = 31 */
 334               	.L__stack_usage = 31
  22:one_square.c  **** 	draw_string( 0, 0, "Click right" );
 335               		.loc 1 22 0
 336 0024 0E94 0000 		call clear_screen
 337               	.LVL10:
  23:one_square.c  **** 	draw_string( 0, 8, "to play" );
 338               		.loc 1 23 0
 339 0028 40E0      		ldi r20,lo8(.LC0)
 340 002a 50E0      		ldi r21,hi8(.LC0)
 341 002c 60E0      		ldi r22,0
 342 002e 80E0      		ldi r24,0
 343 0030 0E94 0000 		call draw_string
 344               	.LVL11:
  24:one_square.c  **** 	show_screen();
 345               		.loc 1 24 0
 346 0034 40E0      		ldi r20,lo8(.LC1)
 347 0036 50E0      		ldi r21,hi8(.LC1)
 348 0038 68E0      		ldi r22,lo8(8)
 349 003a 80E0      		ldi r24,0
 350 003c 0E94 0000 		call draw_string
 351               	.LVL12:
  25:one_square.c  **** 	wait_until( pressed( SW2 ) );
 352               		.loc 1 25 0
 353 0040 0E94 0000 		call show_screen
 354               	.LVL13:
 355               	.L9:
  26:one_square.c  **** 	_delay_ms(50);
 356               		.loc 1 26 0 discriminator 1
 357 0044 7D9B      		sbis 0xf,5
 358 0046 00C0      		rjmp .L9
 359               	.LVL14:
 360               	.LBB10:
 361               	.LBB11:
 362               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 363               		.loc 2 187 0
 364 0048 2FE7      		ldi r18,lo8(79999)
 365 004a 88E3      		ldi r24,hi8(79999)
 366 004c 91E0      		ldi r25,hlo8(79999)
 367 004e 2150      	1:	subi r18,1
 368 0050 8040      		sbci r24,0
 369 0052 9040      		sbci r25,0
 370 0054 01F4      		brne 1b
 371 0056 00C0      		rjmp .
 372 0058 0000      		nop
 373               	.L10:
 374               	.LBE11:
 375               	.LBE10:
  28:one_square.c  **** 
 376               		.loc 1 28 0 discriminator 1
 377 005a 7D99      		sbic 0xf,5
 378 005c 00C0      		rjmp .L10
 379               	.LVL15:
 380               	.LBB12:
 381               	.LBB13:
 382               		.loc 2 187 0
 383 005e 2FEF      		ldi r18,lo8(799999)
 384 0060 84E3      		ldi r24,hi8(799999)
 385 0062 9CE0      		ldi r25,hlo8(799999)
 386 0064 2150      	1:	subi r18,1
 387 0066 8040      		sbci r24,0
 388 0068 9040      		sbci r25,0
 389 006a 01F4      		brne 1b
 390 006c 00C0      		rjmp .
 391 006e 0000      		nop
 392               	.LVL16:
 393               	.LBE13:
 394               	.LBE12:
  51:one_square.c  **** 	srandom( 5198985 );
 395               		.loc 1 51 0
 396 0070 80E0      		ldi r24,lo8(bitmap.2237)
 397 0072 A82E      		mov r10,r24
 398 0074 80E0      		ldi r24,hi8(bitmap.2237)
 399 0076 B82E      		mov r11,r24
 400 0078 98E0      		ldi r25,lo8(8)
 401 007a C92E      		mov r12,r25
 402 007c 28E0      		ldi r18,lo8(8)
 403 007e E22E      		mov r14,r18
 404 0080 00E0      		ldi r16,0
 405 0082 10E0      		ldi r17,0
 406 0084 9801      		movw r18,r16
 407 0086 B901      		movw r22,r18
 408 0088 A801      		movw r20,r16
 409 008a CE01      		movw r24,r28
 410 008c 0196      		adiw r24,1
 411 008e 0E94 0000 		call init_sprite
 412               	.LVL17:
  52:one_square.c  **** 	double angle = ((double)random()) * 2 * M_PI / RANDOM_MAX;
 413               		.loc 1 52 0
 414 0092 69E8      		ldi r22,lo8(-119)
 415 0094 74E5      		ldi r23,lo8(84)
 416 0096 8FE4      		ldi r24,lo8(79)
 417 0098 90E0      		ldi r25,0
 418 009a 0E94 0000 		call srandom
 419               	.LVL18:
  53:one_square.c  **** 	sprite.dx = cos( angle );
 420               		.loc 1 53 0
 421 009e 0E94 0000 		call random
 422               	.LVL19:
 423 00a2 0E94 0000 		call __floatsisf
 424               	.LVL20:
 425 00a6 9B01      		movw r18,r22
 426 00a8 AC01      		movw r20,r24
 427 00aa 0E94 0000 		call __addsf3
 428               	.LVL21:
 429 00ae 2BED      		ldi r18,lo8(-37)
 430 00b0 3FE0      		ldi r19,lo8(15)
 431 00b2 49E4      		ldi r20,lo8(73)
 432 00b4 50E4      		ldi r21,lo8(64)
 433 00b6 0E94 0000 		call __mulsf3
 434               	.LVL22:
 435 00ba 20E0      		ldi r18,0
 436 00bc 30E0      		ldi r19,0
 437 00be 40E0      		ldi r20,0
 438 00c0 50E3      		ldi r21,lo8(48)
 439 00c2 0E94 0000 		call __mulsf3
 440               	.LVL23:
 441 00c6 6B01      		movw r12,r22
 442 00c8 7C01      		movw r14,r24
 443               	.LVL24:
  54:one_square.c  **** 	sprite.dy = sin( angle );
 444               		.loc 1 54 0
 445 00ca 0E94 0000 		call cos
 446               	.LVL25:
 447 00ce 6987      		std Y+9,r22
 448 00d0 7A87      		std Y+10,r23
 449 00d2 8B87      		std Y+11,r24
 450 00d4 9C87      		std Y+12,r25
  55:one_square.c  **** 
 451               		.loc 1 55 0
 452 00d6 C701      		movw r24,r14
 453 00d8 B601      		movw r22,r12
 454 00da 0E94 0000 		call sin
 455               	.LVL26:
 456 00de 6D87      		std Y+13,r22
 457 00e0 7E87      		std Y+14,r23
 458 00e2 8F87      		std Y+15,r24
 459 00e4 988B      		std Y+16,r25
 460               	.L11:
  57:one_square.c  **** 		clear_screen();
 461               		.loc 1 57 0
 462 00e6 7D9B      		sbis 0xf,5
 463 00e8 00C0      		rjmp .L12
  65:one_square.c  **** 	draw_string( 0, 0, "Game Over" );
 464               		.loc 1 65 0
 465 00ea 0E94 0000 		call clear_screen
 466               	.LVL27:
  66:one_square.c  **** 	show_screen();
 467               		.loc 1 66 0
 468 00ee 40E0      		ldi r20,lo8(.LC2)
 469 00f0 50E0      		ldi r21,hi8(.LC2)
 470 00f2 60E0      		ldi r22,0
 471 00f4 80E0      		ldi r24,0
 472 00f6 0E94 0000 		call draw_string
 473               	.LVL28:
  67:one_square.c  **** 
 474               		.loc 1 67 0
 475 00fa 0E94 0000 		call show_screen
 476               	.LVL29:
  69:one_square.c  **** }
 477               		.loc 1 69 0
 478 00fe 2A9A      		sbi 0x5,2
 479               	.L13:
  69:one_square.c  **** }
 480               		.loc 1 69 0 is_stmt 0 discriminator 2
 481 0100 7E9B      		sbis 0xf,6
 482 0102 00C0      		rjmp .L13
 483               	.LVL30:
 484               	.LBB14:
 485               	.LBB15:
 486               		.loc 2 187 0 is_stmt 1
 487 0104 9FEF      		ldi r25,lo8(159999)
 488 0106 20E7      		ldi r18,hi8(159999)
 489 0108 82E0      		ldi r24,hlo8(159999)
 490 010a 9150      	1:	subi r25,1
 491 010c 2040      		sbci r18,0
 492 010e 8040      		sbci r24,0
 493 0110 01F4      		brne 1b
 494 0112 00C0      		rjmp .
 495 0114 0000      		nop
 496               	.LVL31:
 497               	.LBE15:
 498               	.LBE14:
  69:one_square.c  **** }
 499               		.loc 1 69 0
 500 0116 2A98      		cbi 0x5,2
 501               	/* epilogue start */
  70:one_square.c  **** 
 502               		.loc 1 70 0
 503 0118 6596      		adiw r28,21
 504 011a 0FB6      		in __tmp_reg__,__SREG__
 505 011c F894      		cli
 506 011e DEBF      		out __SP_H__,r29
 507 0120 0FBE      		out __SREG__,__tmp_reg__
 508 0122 CDBF      		out __SP_L__,r28
 509 0124 DF91      		pop r29
 510 0126 CF91      		pop r28
 511 0128 1F91      		pop r17
 512 012a 0F91      		pop r16
 513 012c FF90      		pop r15
 514 012e EF90      		pop r14
 515 0130 DF90      		pop r13
 516 0132 CF90      		pop r12
 517               	.LVL32:
 518 0134 BF90      		pop r11
 519 0136 AF90      		pop r10
 520 0138 0895      		ret
 521               	.LVL33:
 522               	.L12:
  58:one_square.c  **** 		update_one_square( & sprite );
 523               		.loc 1 58 0
 524 013a 0E94 0000 		call clear_screen
 525               	.LVL34:
  59:one_square.c  **** 		draw_sprite( &sprite );
 526               		.loc 1 59 0
 527 013e CE01      		movw r24,r28
 528 0140 0196      		adiw r24,1
 529 0142 0E94 0000 		call update_one_square
 530               	.LVL35:
  60:one_square.c  **** 		show_screen();
 531               		.loc 1 60 0
 532 0146 CE01      		movw r24,r28
 533 0148 0196      		adiw r24,1
 534 014a 0E94 0000 		call draw_sprite
 535               	.LVL36:
  61:one_square.c  **** 		_delay_ms( 20 );
 536               		.loc 1 61 0
 537 014e 0E94 0000 		call show_screen
 538               	.LVL37:
 539               	.LBB16:
 540               	.LBB17:
 541               		.loc 2 187 0
 542 0152 8FE3      		ldi r24,lo8(-25537)
 543 0154 9CE9      		ldi r25,hi8(-25537)
 544 0156 0197      	1:	sbiw r24,1
 545 0158 01F4      		brne 1b
 546 015a 00C0      		rjmp .
 547 015c 0000      		nop
 548 015e 00C0      		rjmp .L11
 549               	.LBE17:
 550               	.LBE16:
 551               		.cfi_endproc
 552               	.LFE12:
 554               		.data
 557               	bitmap.2237:
 558 0000 FF        		.byte	-1
 559 0001 81        		.byte	-127
 560 0002 81        		.byte	-127
 561 0003 81        		.byte	-127
 562 0004 81        		.byte	-127
 563 0005 81        		.byte	-127
 564 0006 81        		.byte	-127
 565 0007 FF        		.byte	-1
 566               		.text
 567               	.Letext0:
 568               		.file 3 "/usr/avr/include/stdlib.h"
 569               		.file 4 "/usr/lib/gcc/avr/6.2.0/include/stddef.h"
 570               		.file 5 "/usr/avr/include/stdint.h"
 571               		.file 6 "/usr/avr/include/stdio.h"
 572               		.file 7 "byte.h"
 573               		.file 8 "../cab202_teensy/sprite.h"
 574               		.file 9 "../cab202_teensy/graphics.h"
 575               		.file 10 "../cab202_teensy/ascii_font.h"
 576               		.file 11 "/usr/avr/include/math.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 one_square.c
     /tmp/ccalVq5y.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccalVq5y.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccalVq5y.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccalVq5y.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccalVq5y.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccalVq5y.s:17     .text.update_one_square:0000000000000000 update_one_square
     /tmp/ccalVq5y.s:275    .text.play_one_square:0000000000000000 play_one_square
     /tmp/ccalVq5y.s:557    .data:0000000000000000 bitmap.2237

UNDEFINED SYMBOLS
__addsf3
__floatsisf
__gesf2
__ltsf2
__mulsf3
clear_screen
draw_string
show_screen
init_sprite
srandom
random
cos
sin
draw_sprite
__do_copy_data
