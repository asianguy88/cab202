   1               		.file	"lcd.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.lcd_write,"ax",@progbits
  11               	.global	lcd_write
  13               	lcd_write:
  14               	.LFB8:
  15               		.file 1 "lcd.c"
   1:lcd.c         **** /*
   2:lcd.c         ****  *  CAB202 Teensy Library (cab202_teensy)
   3:lcd.c         ****  *	lcd.c
   4:lcd.c         ****  *
   5:lcd.c         ****  *	Michael, 32/13/2015 12:34:56 AM
   6:lcd.c         ****  *
   7:lcd.c         ****  */
   8:lcd.c         **** #include <avr/io.h>
   9:lcd.c         **** #include <avr/pgmspace.h>
  10:lcd.c         **** #include <util/delay.h>
  11:lcd.c         **** 
  12:lcd.c         **** #include "lcd.h"
  13:lcd.c         **** #include "ascii_font.h"
  14:lcd.c         **** #include "macros.h"
  15:lcd.c         **** 
  16:lcd.c         **** /*
  17:lcd.c         ****  * Function implementations
  18:lcd.c         ****  */
  19:lcd.c         **** void lcd_init(unsigned char contrast) {
  20:lcd.c         **** 	// Set up the pins connected to the LCD as outputs
  21:lcd.c         **** 	SET_OUTPUT(DDRD, SCEPIN);
  22:lcd.c         **** 	SET_OUTPUT(DDRB, RSTPIN);
  23:lcd.c         **** 	SET_OUTPUT(DDRB, DCPIN);
  24:lcd.c         **** 	SET_OUTPUT(DDRB, DINPIN);
  25:lcd.c         **** 	SET_OUTPUT(DDRF, SCKPIN);
  26:lcd.c         **** 
  27:lcd.c         **** 	OUTPUT_LOW(PORTB, RSTPIN);
  28:lcd.c         **** 	OUTPUT_HIGH(PORTD, SCEPIN);
  29:lcd.c         **** 	OUTPUT_HIGH(PORTB, RSTPIN);
  30:lcd.c         **** 
  31:lcd.c         **** 	lcd_write(LCD_C, 0x21); // Enable LCD extended command set
  32:lcd.c         **** 	lcd_write(LCD_C, 0x80 | contrast ); // Set LCD Vop (Contrast)
  33:lcd.c         **** 	lcd_write(LCD_C, 0x04);
  34:lcd.c         **** 	lcd_write(LCD_C, 0x13); // LCD bias mode 1:48
  35:lcd.c         **** 
  36:lcd.c         **** 	lcd_write(LCD_C, 0x0C); // LCD in normal mode.
  37:lcd.c         ****   	lcd_write(LCD_C, 0x20); // Enable LCD basic command set
  38:lcd.c         **** 	lcd_write(LCD_C, 0x0C);
  39:lcd.c         **** 
  40:lcd.c         **** 	lcd_write(LCD_C, 0x40); // Reset row to 0
  41:lcd.c         **** 	lcd_write(LCD_C, 0x80); // Reset column to 0
  42:lcd.c         **** }
  43:lcd.c         **** 
  44:lcd.c         **** void lcd_write(unsigned char dc, unsigned char data) {
  16               		.loc 1 44 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
  45:lcd.c         **** 	// Set the DC pin based on the parameter 'dc' (Hint: use the OUTPUT_WRITE macro)
  46:lcd.c         **** 	OUTPUT_WRITE(PORTB,DCPIN,dc);
  23               		.loc 1 46 0
  24 0000 95B1      		in r25,0x5
  25 0002 9F7D      		andi r25,lo8(-33)
  26 0004 40E2      		ldi r20,lo8(32)
  27 0006 849F      		mul r24,r20
  28 0008 9001      		movw r18,r0
  29 000a 1124      		clr __zero_reg__
  30 000c 922B      		or r25,r18
  31 000e 95B9      		out 0x5,r25
  47:lcd.c         **** 
  48:lcd.c         **** 	// Pull the SCE/SS pin low to signal the LCD we have data
  49:lcd.c         **** 	OUTPUT_LOW(PORTD,SCEPIN);
  32               		.loc 1 49 0
  33 0010 5F98      		cbi 0xb,7
  34               	.LVL1:
  35               	.LBB2:
  50:lcd.c         **** 
  51:lcd.c         **** 	// Write the byte of data using "bit bashing"
  52:lcd.c         **** 	for(int i = 7; i >= 0; i--) {
  36               		.loc 1 52 0
  37 0012 87E0      		ldi r24,lo8(7)
  38 0014 90E0      		ldi r25,0
  39               	.LVL2:
  53:lcd.c         **** 		OUTPUT_LOW(PORTF, SCKPIN) ;
  54:lcd.c         **** 		if((data>>i) & (1 == 1)) {
  40               		.loc 1 54 0
  41 0016 70E0      		ldi r23,0
  42               	.LVL3:
  43               	.L4:
  53:lcd.c         **** 		OUTPUT_LOW(PORTF, SCKPIN) ;
  44               		.loc 1 53 0
  45 0018 8F98      		cbi 0x11,7
  46               		.loc 1 54 0
  47 001a 9B01      		movw r18,r22
  48 001c 082E      		mov r0,r24
  49 001e 00C0      		rjmp 2f
  50               		1:
  51 0020 3595      		asr r19
  52 0022 2795      		ror r18
  53               		2:
  54 0024 0A94      		dec r0
  55 0026 02F4      		brpl 1b
  56 0028 20FF      		sbrs r18,0
  57 002a 00C0      		rjmp .L2
  55:lcd.c         **** 			OUTPUT_HIGH(PORTB, DINPIN);
  58               		.loc 1 55 0
  59 002c 2E9A      		sbi 0x5,6
  60               	.L3:
  56:lcd.c         **** 		} else {
  57:lcd.c         **** 			OUTPUT_LOW(PORTB, DINPIN);
  58:lcd.c         **** 		}
  59:lcd.c         **** 		OUTPUT_HIGH(PORTF, SCKPIN);
  61               		.loc 1 59 0 discriminator 2
  62 002e 8F9A      		sbi 0x11,7
  52:lcd.c         **** 		OUTPUT_LOW(PORTF, SCKPIN) ;
  63               		.loc 1 52 0 discriminator 2
  64               	.LVL4:
  65 0030 0197      		sbiw r24,1
  66 0032 00F4      		brcc .L4
  67               	.LBE2:
  60:lcd.c         **** 	}
  61:lcd.c         **** 
  62:lcd.c         **** 	// Pull SCE/SS high to signal the LCD we are done
  63:lcd.c         **** 	OUTPUT_HIGH(PORTD,SCEPIN);
  68               		.loc 1 63 0
  69 0034 5F9A      		sbi 0xb,7
  70 0036 0895      		ret
  71               	.L2:
  72               	.LBB3:
  57:lcd.c         **** 		}
  73               		.loc 1 57 0
  74 0038 2E98      		cbi 0x5,6
  75 003a 00C0      		rjmp .L3
  76               	.LBE3:
  77               		.cfi_endproc
  78               	.LFE8:
  80               		.section	.text.lcd_init,"ax",@progbits
  81               	.global	lcd_init
  83               	lcd_init:
  84               	.LFB7:
  19:lcd.c         **** 	// Set up the pins connected to the LCD as outputs
  85               		.loc 1 19 0
  86               		.cfi_startproc
  87               	.LVL5:
  88 0000 CF93      		push r28
  89               	.LCFI0:
  90               		.cfi_def_cfa_offset 3
  91               		.cfi_offset 28, -2
  92               	/* prologue: function */
  93               	/* frame size = 0 */
  94               	/* stack size = 1 */
  95               	.L__stack_usage = 1
  96 0002 C82F      		mov r28,r24
  21:lcd.c         **** 	SET_OUTPUT(DDRB, RSTPIN);
  97               		.loc 1 21 0
  98 0004 579A      		sbi 0xa,7
  22:lcd.c         **** 	SET_OUTPUT(DDRB, DCPIN);
  99               		.loc 1 22 0
 100 0006 249A      		sbi 0x4,4
  23:lcd.c         **** 	SET_OUTPUT(DDRB, DINPIN);
 101               		.loc 1 23 0
 102 0008 259A      		sbi 0x4,5
  24:lcd.c         **** 	SET_OUTPUT(DDRF, SCKPIN);
 103               		.loc 1 24 0
 104 000a 269A      		sbi 0x4,6
  25:lcd.c         **** 
 105               		.loc 1 25 0
 106 000c 879A      		sbi 0x10,7
  27:lcd.c         **** 	OUTPUT_HIGH(PORTD, SCEPIN);
 107               		.loc 1 27 0
 108 000e 2C98      		cbi 0x5,4
  28:lcd.c         **** 	OUTPUT_HIGH(PORTB, RSTPIN);
 109               		.loc 1 28 0
 110 0010 5F9A      		sbi 0xb,7
  29:lcd.c         **** 
 111               		.loc 1 29 0
 112 0012 2C9A      		sbi 0x5,4
  31:lcd.c         **** 	lcd_write(LCD_C, 0x80 | contrast ); // Set LCD Vop (Contrast)
 113               		.loc 1 31 0
 114 0014 61E2      		ldi r22,lo8(33)
 115 0016 80E0      		ldi r24,0
 116               	.LVL6:
 117 0018 0E94 0000 		call lcd_write
 118               	.LVL7:
  32:lcd.c         **** 	lcd_write(LCD_C, 0x04);
 119               		.loc 1 32 0
 120 001c 6C2F      		mov r22,r28
 121 001e 6068      		ori r22,lo8(-128)
 122 0020 80E0      		ldi r24,0
 123 0022 0E94 0000 		call lcd_write
 124               	.LVL8:
  33:lcd.c         **** 	lcd_write(LCD_C, 0x13); // LCD bias mode 1:48
 125               		.loc 1 33 0
 126 0026 64E0      		ldi r22,lo8(4)
 127 0028 80E0      		ldi r24,0
 128 002a 0E94 0000 		call lcd_write
 129               	.LVL9:
  34:lcd.c         **** 
 130               		.loc 1 34 0
 131 002e 63E1      		ldi r22,lo8(19)
 132 0030 80E0      		ldi r24,0
 133 0032 0E94 0000 		call lcd_write
 134               	.LVL10:
  36:lcd.c         ****   	lcd_write(LCD_C, 0x20); // Enable LCD basic command set
 135               		.loc 1 36 0
 136 0036 6CE0      		ldi r22,lo8(12)
 137 0038 80E0      		ldi r24,0
 138 003a 0E94 0000 		call lcd_write
 139               	.LVL11:
  37:lcd.c         **** 	lcd_write(LCD_C, 0x0C);
 140               		.loc 1 37 0
 141 003e 60E2      		ldi r22,lo8(32)
 142 0040 80E0      		ldi r24,0
 143 0042 0E94 0000 		call lcd_write
 144               	.LVL12:
  38:lcd.c         **** 
 145               		.loc 1 38 0
 146 0046 6CE0      		ldi r22,lo8(12)
 147 0048 80E0      		ldi r24,0
 148 004a 0E94 0000 		call lcd_write
 149               	.LVL13:
  40:lcd.c         **** 	lcd_write(LCD_C, 0x80); // Reset column to 0
 150               		.loc 1 40 0
 151 004e 60E4      		ldi r22,lo8(64)
 152 0050 80E0      		ldi r24,0
 153 0052 0E94 0000 		call lcd_write
 154               	.LVL14:
  41:lcd.c         **** }
 155               		.loc 1 41 0
 156 0056 60E8      		ldi r22,lo8(-128)
 157 0058 80E0      		ldi r24,0
 158               	/* epilogue start */
  42:lcd.c         **** 
 159               		.loc 1 42 0
 160 005a CF91      		pop r28
 161               	.LVL15:
  41:lcd.c         **** }
 162               		.loc 1 41 0
 163 005c 0C94 0000 		jmp lcd_write
 164               	.LVL16:
 165               		.cfi_endproc
 166               	.LFE7:
 168               		.section	.text.lcd_clear,"ax",@progbits
 169               	.global	lcd_clear
 171               	lcd_clear:
 172               	.LFB9:
  64:lcd.c         **** }
  65:lcd.c         **** 
  66:lcd.c         **** void lcd_clear(void) {
 173               		.loc 1 66 0
 174               		.cfi_startproc
 175 0000 CF93      		push r28
 176               	.LCFI1:
 177               		.cfi_def_cfa_offset 3
 178               		.cfi_offset 28, -2
 179 0002 DF93      		push r29
 180               	.LCFI2:
 181               		.cfi_def_cfa_offset 4
 182               		.cfi_offset 29, -3
 183               	/* prologue: function */
 184               	/* frame size = 0 */
 185               	/* stack size = 2 */
 186               	.L__stack_usage = 2
 187               	.LVL17:
 188               		.loc 1 66 0
 189 0004 C8EF      		ldi r28,lo8(-8)
 190 0006 D1E0      		ldi r29,lo8(1)
 191               	.LVL18:
 192               	.L8:
 193               	.LBB4:
  67:lcd.c         **** 	// For each of the bytes on the screen, write an empty byte
  68:lcd.c         **** 	// We don't need to start from the start: bonus question - why not?
  69:lcd.c         **** 	for (int i = 0; i < LCD_X * LCD_Y / 8; i++) {
  70:lcd.c         **** 		lcd_write(LCD_D, 0x00);
 194               		.loc 1 70 0 discriminator 3
 195 0008 60E0      		ldi r22,0
 196 000a 81E0      		ldi r24,lo8(1)
 197 000c 0E94 0000 		call lcd_write
 198               	.LVL19:
 199 0010 2197      		sbiw r28,1
 200               	.LVL20:
  69:lcd.c         **** 		lcd_write(LCD_D, 0x00);
 201               		.loc 1 69 0 discriminator 3
 202 0012 01F4      		brne .L8
 203               	/* epilogue start */
 204               	.LBE4:
  71:lcd.c         **** 	}
  72:lcd.c         **** }
 205               		.loc 1 72 0
 206 0014 DF91      		pop r29
 207 0016 CF91      		pop r28
 208               	.LVL21:
 209 0018 0895      		ret
 210               		.cfi_endproc
 211               	.LFE9:
 213               		.section	.text.lcd_position,"ax",@progbits
 214               	.global	lcd_position
 216               	lcd_position:
 217               	.LFB10:
  73:lcd.c         **** 
  74:lcd.c         **** void lcd_position(unsigned char x, unsigned char y) {
 218               		.loc 1 74 0
 219               		.cfi_startproc
 220               	.LVL22:
 221 0000 CF93      		push r28
 222               	.LCFI3:
 223               		.cfi_def_cfa_offset 3
 224               		.cfi_offset 28, -2
 225               	/* prologue: function */
 226               	/* frame size = 0 */
 227               	/* stack size = 1 */
 228               	.L__stack_usage = 1
 229 0002 C82F      		mov r28,r24
  75:lcd.c         **** 	lcd_write(LCD_C, (0x40 | y )); // Reset row to 0
 230               		.loc 1 75 0
 231 0004 6064      		ori r22,lo8(64)
 232               	.LVL23:
 233 0006 80E0      		ldi r24,0
 234               	.LVL24:
 235 0008 0E94 0000 		call lcd_write
 236               	.LVL25:
  76:lcd.c         **** 	lcd_write(LCD_C, (0x80 | x )); // Reset column to 0
 237               		.loc 1 76 0
 238 000c 6C2F      		mov r22,r28
 239 000e 6068      		ori r22,lo8(-128)
 240 0010 80E0      		ldi r24,0
 241               	/* epilogue start */
  77:lcd.c         **** }
 242               		.loc 1 77 0
 243 0012 CF91      		pop r28
 244               	.LVL26:
  76:lcd.c         **** 	lcd_write(LCD_C, (0x80 | x )); // Reset column to 0
 245               		.loc 1 76 0
 246 0014 0C94 0000 		jmp lcd_write
 247               	.LVL27:
 248               		.cfi_endproc
 249               	.LFE10:
 251               		.text
 252               	.Letext0:
 253               		.file 2 "/usr/avr/include/stdint.h"
 254               		.file 3 "ascii_font.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 lcd.c
     /tmp/ccr0iov7.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccr0iov7.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccr0iov7.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccr0iov7.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccr0iov7.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccr0iov7.s:13     .text.lcd_write:0000000000000000 lcd_write
     /tmp/ccr0iov7.s:83     .text.lcd_init:0000000000000000 lcd_init
     /tmp/ccr0iov7.s:171    .text.lcd_clear:0000000000000000 lcd_clear
     /tmp/ccr0iov7.s:216    .text.lcd_position:0000000000000000 lcd_position

NO UNDEFINED SYMBOLS
